{"version":3,"sources":["components/Node/Node.jsx","Algorithms/Helper/minHeap.js","Algorithms/dijkstra.js","Algorithms/depthFirstSearch.js","Algorithms/breadthFirstSearch.js","Algorithms/bestFirstSearch.js","Algorithms/aStarSearch.js","Algorithms/bidirectionalSearch.js","MazeGenerationAlgorithms/RecursiveDivisionMazeGeneration.js","MazeGenerationAlgorithms/RandomMaze.js","components/VisualizerComponent.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","toggleVisited","ref","current","className","togglePath","toggleReset","toggleStart","toggleFinish","toggleWall","state","extraclassName","React","createRef","this","row","col","isStart","isFinish","isVisited","isWall","isPath","onMouseDown","onMouseEnter","onMouseUp","data-toggle","data-placement","title","id","Component","MinHeap","elements","getLeftChildIndex","parentIndex","getRightChildIndex","getParentIndex","childIndex","Math","floor","hasLeftChild","heapNode","length","hasRightChild","hasParent","getLeftChildData","getRightChildData","getParentData","extractMin","shift","minValue","lastValue","pop","unshift","heapifyDown","getMin","insert","node","push","heapifyUp","index","smallerChildIndex","distance","currentData","smallestChildData","currentIndex","parent","isEmpty","element","dijkstra","grid","startNode","finishNode","visitedNodeOrder","unvisitedNodes","nodes","getAllNodes","sortUnvistedNodesByDistance","closestNode","console","log","Infinity","updateUnvisitedNeighbours","sort","nodeA","nodeB","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","previousNode","hitEdge","getNeighbourNodes","getNeighbours","bestFirstSearch","gridRow","distanceFromTarget","abs","UpdateDistance","visitedNodesInOrder","minHeap","currentNode","updateNeighbours","hurestics","targetNode","huresticFunction","manhattanDistance","max","diagonalDistance","sqrt","pow","euclideanDistance","direction","isVisitedFromOther","recursiveDivsionUtil","startRow","endRow","startCol","endCol","boundaryWalls","wallsToAnimate","recursiveDivsion","possibleRows","i","possibleColumns","randomRowIndex","random","randomColumnIndex","selectedRowPartition","selectedColumnPartition","START_POS_ROW","START_POS_COL","FINISH_POS_ROW","FINISH_POS_COL","SLOW_SPEED","MEDIUM_SPEED","FAST_SPEED","VisualizerComponent","handleMouseClick","newGrid","removeWall","setState","buildWall","handleMouseDown","tempGrid","nodeRef","mousePressed","handleMouseEnter","handleMouseUp","newNode","createNode","hCost","gCost","fCost","nextNode","clearVisitedNode","resetStartNode","resetFinishNode","resetWallNode","resetVisitedNode","animateDijkstra","visitedNodeInOrder","shortestPath","animationSpeed","setTimeout","printShortestPath","mousePointerEvents","visualizeDijkstra","slice","getShortestPath","animateDepthFirstSearch","DFSPath","visualizeDepthFirstSearch","visitedNodes","stack","neighbourNodes","depthFirstSearch","getDFSPath","animateBreadthFirstSearch","visualizeBreadthFirstSearch","queue","breadthFristSearch","BFSPath","getBFSPath","animateBestFirstSearch","GBFSPath","visualizeBestFirstSearch","getGBFSPath","animateAStarSearch","AStarPath","visualizeAStarSearch","openList","closedSet","Set","smallIndex","splice","add","l","has","ng","includes","aStarSearch","aStarPath","getAStarPath","animateBidirectionalSearch","visualizeBidirectionalSearch","queue1","queue2","fromStart","fromFinish","finishNeighbours","startNeighbours","bidirectionalSearch","path","middle1","path1","path2","middle2","concat","getBidirectionalShortestPath","visualizeSelectedAlgorithm","selectedAlgorithm","window","alert","selectAlgorithm","algorithm","description","selectSpeed","speed","generateWalls","randomValue","randomeMaze","animateWalls","columnRow","rowRef","column","Navbar","bg","Brand","href","NavDropdown","style","pointerEvents","Item","onClick","Nav","Link","map","rowId","key","columnId","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e6647c7c.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport './Node.css'\r\n\r\nexport class Node extends Component {\r\n\r\n    constructor(props) {\r\n      super(props)\r\n      this.state = {\r\n        extraclassName : ''\r\n      }\r\n\r\n      this.ref = React.createRef()\r\n    }\r\n  \r\n    //Toggle node to visited\r\n    toggleVisited = () => {\r\n      this.ref.current.className = 'node visited-node'\r\n    }\r\n\r\n    togglePath = () => {\r\n      this.ref.current.className = 'node path-node'\r\n    }\r\n\r\n    toggleReset = () => {\r\n      this.ref.current.className = 'node '\r\n    }\r\n\r\n    toggleStart = () => {\r\n      this.ref.current.className = 'node start-node'\r\n    }\r\n\r\n    toggleFinish = () => {\r\n      this.ref.current.className = 'node finish-node'\r\n    }\r\n\r\n    toggleWall = () => {\r\n      this.ref.current.className = 'node wall-node'\r\n    }\r\n    \r\n\r\n    render() {\r\n        const {row, col, isStart, isFinish, isVisited, isWall, isPath, onMouseDown, onMouseEnter, onMouseUp} = this.props\r\n        //If current node is Start or target node then add additions css property to them\r\n        const extraclassName = (isPath)? 'path-node' : (isStart)? 'start-node' : (isFinish)? 'finish-node' : (isWall) ? 'wall-node':(isVisited) ? 'visited-node' : ''\r\n        //console.log(extraclassName)\r\n\r\n        return (\r\n          <div ref={this.ref}\r\n          data-toggle=\"tooltip\" data-placement=\"top\" title={`${row} ${col}`}\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraclassName}`}\r\n            \r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseUp={() => onMouseUp()}>\r\n           </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Node\r\n","export class MinHeap {\r\n    \r\n        constructor(elements) {\r\n           this.heapNode = [];\r\n           //console.log(this.heapNode)\r\n           for(let element of elements){\r\n               \r\n               this.insert(element)\r\n           }\r\n         }\r\n\r\n         getLeftChildIndex = parentIndex => {\r\n           return parentIndex * 2 + 1;\r\n         };\r\n\r\n         getRightChildIndex = parentIndex => {\r\n           return parentIndex * 2 + 2;\r\n         };\r\n\r\n         getParentIndex = childIndex => {\r\n           return Math.floor((childIndex - 1) / 2);\r\n         };\r\n\r\n         hasLeftChild = parentIndex => {\r\n           return this.getLeftChildIndex(parentIndex) < this.heapNode.length;\r\n         };\r\n\r\n         hasRightChild = parentIndex => {\r\n           return this.getRightChildIndex(parentIndex) < this.heapNode.length;\r\n         };\r\n\r\n         hasParent = childIndex => {\r\n           return this.getParentIndex(childIndex) >= 0;\r\n         };\r\n\r\n         getLeftChildData = parentIndex => {\r\n           return this.heapNode[this.getLeftChildIndex(parentIndex)];\r\n         };\r\n\r\n         getRightChildData = parentIndex => {\r\n           return this.heapNode[this.getRightChildIndex(parentIndex)];\r\n         };\r\n\r\n         getParentData = childIndex => {\r\n           return this.heapNode[this.getParentIndex(childIndex)];\r\n         };\r\n\r\n         extractMin = () => {\r\n            \r\n           if(this.heapNode.length === 1){\r\n               return this.heapNode.shift();\r\n           }\r\n           if (this.heapNode.length !== 0) {\r\n             const minValue = this.heapNode.shift();\r\n             const lastValue = this.heapNode.pop();\r\n             this.heapNode.unshift(lastValue);\r\n             this.heapifyDown();\r\n             return minValue;\r\n           }\r\n         };\r\n\r\n         getMin = () => {\r\n           if (this.heapNode.length !== 0) {\r\n             return this.heapNode[0];\r\n           }\r\n         };\r\n\r\n         insert = node => {\r\n           this.heapNode.push(node);\r\n           this.heapifyUp();\r\n         };\r\n\r\n         heapifyDown = () => {\r\n           let index = 0\r\n           while(this.hasLeftChild(index)){\r\n               let smallerChildIndex = this.getLeftChildIndex(index)\r\n               if(this.hasRightChild(index) && this.getLeftChildData(index).distance > this.getRightChildData(index).distance){\r\n                   smallerChildIndex = this.getRightChildIndex(index)\r\n               }\r\n\r\n               let currentData = (this.heapNode[index])\r\n               let smallestChildData = (this.heapNode[smallerChildIndex])\r\n\r\n               if(currentData.distance < smallestChildData.distance){\r\n                    break;\r\n               }else{\r\n                    this.heapNode[smallerChildIndex] = currentData\r\n                    this.heapNode[index] = smallestChildData\r\n               }\r\n               index = smallerChildIndex\r\n           }\r\n         };\r\n\r\n         heapifyUp = () => {\r\n           let currentIndex = this.heapNode.length - 1;\r\n           while (this.hasParent(currentIndex)) {\r\n             let parentIndex = this.getParentIndex(currentIndex);\r\n             let parent = (this.heapNode[parentIndex]);\r\n             let current = (this.heapNode[currentIndex]);\r\n             if (current.distance < parent.distance) {\r\n               this.heapNode[parentIndex] = current;\r\n               this.heapNode[currentIndex] = parent;\r\n               currentIndex = parentIndex;\r\n             } else {\r\n               break;\r\n             }\r\n           }\r\n         };\r\n\r\n         isEmpty = () => {\r\n            return this.heapNode.length === 0\r\n         }\r\n}\r\n","import {MinHeap} from './Helper/minHeap'\r\nconst heap = new MinHeap([])\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    \r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodeOrder = []\r\n    startNode.distance = 0\r\n    \r\n\r\n    /*heap.insert(startNode)\r\n    \r\n    while (!heap.isEmpty()) {\r\n        const closestNode = heap.extractMin()\r\n        if(closestNode.isVisited) continue\r\n        closestNode.isVisited = true;\r\n        //If the node is wall then ignore it\r\n        if(closestNode.isWall) continue\r\n        //If the start node is fully surrounded by wall\r\n        if(closestNode.distance === Infinity) return visitedNodeOrder\r\n        //If the node is visited then add it to the visited list\r\n        visitedNodeOrder.push(closestNode)\r\n        //If target node is found\r\n        if(closestNode === finishNode){\r\n            return visitedNodeOrder\r\n        }\r\n        //Update the distance and parent of the neighbouring nodes\r\n        updateUnvisitedNeighbours(closestNode, grid)\r\n    }*/\r\n    const unvisitedNodes = getAllNodes(grid)\r\n    while (unvisitedNodes.length !== 0) {\r\n        sortUnvistedNodesByDistance(unvisitedNodes)\r\n        const closestNode = unvisitedNodes.shift()\r\n        \r\n        //const closestNode = heap.extractMin()\r\n        console.log(closestNode)\r\n        \r\n        //If the start node is fully surrounded by wall\r\n        if(closestNode.distance === Infinity) return visitedNodeOrder\r\n\r\n        if(closestNode.isVisited) continue\r\n\r\n        closestNode.isVisited = true;\r\n        //If the node is wall then ignore it\r\n        if(closestNode.isWall) continue\r\n        \r\n        //If the node is visited then add it to the visited list\r\n        visitedNodeOrder.push(closestNode)\r\n        //If target node is found\r\n        if(closestNode === finishNode){\r\n            //heap.insert(visitedNodeOrder)\r\n            //console.log('min '+JSON.stringify(heap.extractMin()))\r\n            return visitedNodeOrder\r\n        }\r\n        //Update the distance and parent of the neighbouring nodes\r\n        updateUnvisitedNeighbours(closestNode, grid)\r\n    }\r\n}\r\n\r\nfunction sortUnvistedNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid){\r\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid)\r\n    for(const neighbour of unvisitedNeighbours){\r\n        neighbour.distance = node.distance + 1\r\n        neighbour.previousNode = node\r\n        \r\n       // heap.insert(neighbour)\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid){\r\n    const  neighbours = []\r\n    const {row, col} = node\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n\r\n    return neighbours.filter((neighbour) => (neighbour.isVisited === false))\r\n    /*console.log(neighbours.map((node) => console.log('['+node.row+\" \"+node.col+']'+' '+node.isVisited))+'neighbors of '+ node.row +\" \"+ node.col +\"= \")\r\n    return neighbours*/\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    const nodes = []\r\n    for(let row of grid){\r\n        for(let node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes\r\n}\r\n\r\nexport function getShortestPath(finishNode){\r\n    const shortestPath = []\r\n     \r\n    //if there is no path\r\n     if(finishNode.previousNode === null)\r\n        return shortestPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode != null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        shortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return shortestPath\r\n}","var hitEdge = false\r\nexport function depthFirstSearch(grid, startNode, finishNode){\r\n    \r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodes = []\r\n    const stack = [startNode]\r\n    while(stack.length !== 0){\r\n        const currentNode = stack.pop()\r\n        if(currentNode.isWall) continue\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodes.push(currentNode)\r\n        if(currentNode === finishNode)\r\n            return visitedNodes\r\n        const neighbourNodes = getNeighbourNodes(grid, currentNode)\r\n        for(const neighbour of neighbourNodes){\r\n            neighbour.previousNode = currentNode\r\n            stack.push(neighbour)\r\n        }\r\n    }\r\n\r\n    //If target not found\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbourNodes(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n    \r\n    if(hitEdge){\r\n        if(row > 0) neighbours.push(grid[row - 1][col])\r\n        if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n        if(col > 0) neighbours.push(grid[row][col - 1])\r\n        if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n        else{\r\n            hitEdge = false\r\n        }\r\n    }else{\r\n        if(col > 0) neighbours.push(grid[row][col - 1])\r\n        if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n        if(row > 0) neighbours.push(grid[row - 1][col])\r\n        if(row < grid.length - 1) \r\n            neighbours.push(grid[row + 1][col])\r\n        else\r\n            hitEdge = true\r\n    }\r\n    return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nexport function getDFSPath(finishNode){\r\n    const DFSPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return DFSPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        DFSPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return DFSPath\r\n}\r\n","\r\nexport function breadthFristSearch(grid, startNode, finishNode){\r\n\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodes = []\r\n    const queue = [startNode]\r\n    while(queue.length !== 0){\r\n        const currentNode = queue.shift()\r\n        if(currentNode.isWall) continue\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodes.push(currentNode)\r\n        if(currentNode === finishNode) return visitedNodes\r\n        const neighbours = getNeighbours(grid, currentNode)\r\n        for(const neighbour of neighbours){\r\n            neighbour.previousNode = currentNode\r\n            queue.push(neighbour)\r\n        }\r\n    }\r\n\r\n    //If target not found\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbours(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n\r\n    return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nexport function getBFSPath(finishNode){\r\n    const BFSPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return BFSPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        BFSPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return BFSPath\r\n}\r\n","import {MinHeap} from './Helper/minHeap'\r\n\r\nexport function bestFirstSearch(grid, startNode, finishNode){\r\n\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n    \r\n    UpdateDistance(grid, finishNode)\r\n    //finishNode = grid[finishNode.row][finishNode.col]\r\n    //console.log(grid)\r\n\r\n    const visitedNodesInOrder = []\r\n    //startNode.distance = 0\r\n    const minHeap = new MinHeap([])\r\n    minHeap.insert(startNode)\r\n    while(!minHeap.isEmpty()){\r\n        const currentNode = minHeap.extractMin()\r\n        if(currentNode.isWall) continue\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodesInOrder.push(currentNode)\r\n        if(currentNode === finishNode)\r\n            return visitedNodesInOrder\r\n        updateNeighbours(grid, currentNode, minHeap)\r\n    }\r\n    /*const priorityQueue = [startNode]\r\n    while(priorityQueue.length !== 0){\r\n        sortUnvistedNodesByDistance(priorityQueue)\r\n        const currentNode = priorityQueue.shift()\r\n        console.log(priorityQueue.length)\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodesInOrder.push(currentNode)\r\n        if(currentNode.row === finishNode.row && currentNode.col === finishNode.col){\r\n            console.log(currentNode)\r\n            console.log(finishNode)\r\n            return visitedNodesInOrder\r\n        }\r\n\r\n        const neighbours = getUnvisitedNeighbours(grid, currentNode)\r\n        for(const neighbour of neighbours){\r\n            neighbour.previousNode = currentNode\r\n            priorityQueue.push(neighbour)\r\n        }\r\n    }*/\r\n    return visitedNodesInOrder\r\n}\r\n\r\nfunction sortUnvistedNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateNeighbours(grid, node, minHeap){\r\n    const unvisitedNeighbours = getUnvisitedNeighbours(grid, node)\r\n    for(let neighbour of unvisitedNeighbours){\r\n        //neighbour.distance = node.distance + 1\r\n        neighbour.previousNode = node\r\n        minHeap.insert(neighbour)\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n   \r\n    return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nfunction UpdateDistance (grid, finishNode){\r\n    const {row, col} = finishNode\r\n    for(let gridRow of grid){\r\n        for(let node of gridRow){\r\n            const distanceFromTarget = Math.abs(node.row - row) + Math.abs(node.col - col)\r\n            /*const newNode = {\r\n                ...node,\r\n                distance : distanceFromTarget\r\n            }*/\r\n            grid[node.row][node.col].distance = distanceFromTarget\r\n        }\r\n    }\r\n    return grid\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    const nodes = []\r\n    for(let row of grid){\r\n        for(let node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes\r\n}\r\n\r\nexport function getGBFSPath(finishNode){\r\n    const GBFSPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return GBFSPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        GBFSPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return GBFSPath\r\n}\r\n","import {MinHeap} from './Helper/minHeap'\r\nimport Heap from 'heap'\r\n\r\n/*export function aStarSearch(grid, startNode, finishNode){\r\n\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    let openList = new Heap(function(nodeA, nodeB) {\r\n        return nodeA.fCost - nodeB.fCost;\r\n    })\r\n\r\n    const visitedNodes = []\r\n    \r\n    //const openSet = new Set()\r\n    const closedSet = new Set()\r\n\r\n    startNode.fCost = 0\r\n    startNode.gCost = 0\r\n    startNode.hCost = manhattanDistance(startNode, finishNode)\r\n\r\n    openList.push(startNode)\r\n    //openSet.add(startNode)\r\n\r\n    while(!openList.empty()){\r\n\r\n        \r\n        openList.heapify();\r\n        //console.log(openList);\r\n        const currentNode = openList.pop()\r\n        console.log(currentNode.fCost);\r\n        console.log(currentNode)\r\n        //openSet.delete(currentNode)\r\n        closedSet.add(currentNode)\r\n\r\n        visitedNodes.push(currentNode)\r\n\r\n        if(currentNode === finishNode){\r\n            return visitedNodes\r\n        }\r\n\r\n        const neighbours = getNeighbours(grid, currentNode)\r\n        for(let i = 0, l = neighbours.length; i < l ; ++i){\r\n            const neighbour = neighbours[i]\r\n            \r\n            if(closedSet.has(neighbour))\r\n                continue\r\n            \r\n            let ng = currentNode.gCost + 1;\r\n\r\n            if(openList.has(neighbour)){\r\n\r\n                if(ng < neighbour.gCost){\r\n                    neighbour.gCost = ng\r\n                    neighbour.hCost = hurestics(neighbour, finishNode, 'manhattan_distance')\r\n                    neighbour.fCost = neighbour.gCost + neighbour.hCost\r\n                    neighbour.previousNode = currentNode   \r\n                    openList.updateItem(neighbour) \r\n                }\r\n\r\n                if(/*!openSet.has(neighbour)!openList.has(neighbour)){\r\n                    //openList.push(neighbour)\r\n                    //openSet.add(neighbour)\r\n                }else{\r\n                    //openList.updateItem(neighbour)\r\n                }\r\n            }else{\r\n                    neighbour.gCost = ng\r\n                    neighbour.hCost = hurestics(neighbour, finishNode, 'manhattan_distance')\r\n                    neighbour.fCost = neighbour.gCost + neighbour.hCost\r\n                    neighbour.previousNode = currentNode   \r\n                    openList.push(neighbour) \r\n            }\r\n\r\n        }  \r\n    }\r\n\r\n}*/\r\n\r\nexport function aStarSearch(grid, startNode, finishNode){\r\n\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    let openList = []\r\n\r\n    const visitedNodes = []\r\n    \r\n    //const openSet = new Set()\r\n    const closedSet = new Set()\r\n\r\n    startNode.fCost = 0\r\n    startNode.gCost = 0\r\n    startNode.hCost = manhattanDistance(startNode, finishNode)\r\n\r\n    openList.push(startNode)\r\n    //openSet.add(startNode)\r\n\r\n    while(openList.length !== 0){\r\n\r\n        \r\n        //openList.heapify();\r\n        //console.log(openList);\r\n        let smallIndex = 0;\r\n\r\n        for(let i=0; i<openList.length; i++){\r\n            if( openList[i].fCost < openList[smallIndex].fCost){\r\n                smallIndex = i;\r\n            }\r\n        }\r\n        console.log(smallIndex);\r\n        let currentNode = openList.splice(smallIndex, 1)[0];\r\n        console.log(currentNode)\r\n        closedSet.add(currentNode)\r\n\r\n        visitedNodes.push(currentNode)\r\n\r\n        if(currentNode === finishNode){\r\n            return visitedNodes\r\n        }\r\n\r\n        const neighbours = getNeighbours(grid, currentNode)\r\n        //console.log(neighbours)\r\n        for(let i = 0, l = neighbours.length; i < l ; ++i){\r\n            const neighbour = neighbours[i]\r\n            \r\n            //console.log(\"Parent = \"+ currentNode.row+\" \"+currentNode.col)\r\n\r\n            if(closedSet.has(neighbour))\r\n                continue\r\n            \r\n            let ng = currentNode.gCost + 1;\r\n\r\n            if(openList.includes(neighbour)){\r\n                console.log(\"before \"+neighbour.gCost+\" new \"+ng)\r\n                if(ng < neighbour.gCost){\r\n                    neighbour.gCost = ng\r\n                    neighbour.hCost = hurestics(neighbour, finishNode, 'manhattan_distance')\r\n                    neighbour.fCost = neighbour.gCost + neighbour.hCost\r\n                    neighbour.previousNode = currentNode   \r\n                    //openList.push(neighbour) \r\n                    console.log(\"after \"+neighbour.gCost)\r\n                }\r\n\r\n            }else{\r\n                    neighbour.gCost = ng\r\n                    neighbour.hCost = hurestics(neighbour, finishNode, 'manhattan_distance')\r\n                    neighbour.fCost = neighbour.gCost + neighbour.hCost\r\n                    neighbour.previousNode = currentNode   \r\n                    openList.push(neighbour) \r\n            }\r\n\r\n        }  \r\n    }\r\n\r\n}\r\n\r\nfunction getDistance(node, target){\r\n    return manhattanDistance(node, target)\r\n}\r\n\r\nfunction hurestics(node, targetNode, huresticFunction){\r\n    if(huresticFunction === 'manhattan_distance'){\r\n        return manhattanDistance(node, targetNode)\r\n    }else if(huresticFunction === 'diagonal_distance'){\r\n        return diagonalDistance(node, targetNode)\r\n    }else{\r\n        return euclideanDistance(node, targetNode)\r\n    }\r\n}\r\n\r\nfunction manhattanDistance(node, targetNode){\r\n    return Math.abs(node.row - targetNode.row) + Math.abs(node.col - targetNode.col)\r\n}\r\n\r\nfunction diagonalDistance(node, targetNode){\r\n    return Math.max(Math.abs(node.row - targetNode.row), Math.abs(node.col - targetNode.col))\r\n}\r\n\r\nfunction euclideanDistance(node, targetNode){\r\n    return Math.sqrt(Math.pow((node.row - targetNode.row), 2) + Math.pow((node.col - targetNode.col), 2))\r\n}\r\n\r\n\r\nfunction getNeighbours(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n    \r\n    //console.log(neighbours)\r\n    return neighbours.filter(neighbour => !neighbour.isWall)\r\n}\r\n\r\nexport function getAStarPath(finishNode){\r\n    const aStarPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return aStarPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        aStarPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return aStarPath\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    const nodes = []\r\n    for(let row of grid){\r\n        for(let node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes\r\n}","export function bidirectionalSearch(grid, startNode, finishNode) {\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodes = []\r\n    const queue1 = [startNode]\r\n    const queue2 = [finishNode]\r\n    while(queue1.length !== 0 && queue2.length !== 0){\r\n        const fromStart = queue1.shift()\r\n        const fromFinish = queue2.shift()\r\n        if(fromFinish.isVisited){\r\n            console.log(fromFinish)\r\n            visitedNodes.push(fromFinish)\r\n            return visitedNodes\r\n        }\r\n        if(fromStart.isVisitedFromOther){\r\n            console.log(fromStart)\r\n            visitedNodes.push(fromStart)\r\n            return visitedNodes\r\n        }\r\n        if(fromStart === fromFinish){\r\n            return visitedNodes\r\n        }\r\n\r\n        if(fromStart.isVisited && fromFinish.isVisitedFromOther) \r\n            continue\r\n        else if(fromStart.isVisited){\r\n            fromFinish.isVisitedFromOther = true;\r\n            visitedNodes.push(fromFinish)\r\n            const finishNeighbours = getNeighbours(grid, fromFinish, 'from_finish')\r\n            for(const neighbour of finishNeighbours){\r\n                neighbour.nextNode = fromFinish\r\n                queue2.push(neighbour)\r\n            }\r\n        }else if(fromFinish.isVisitedFromOther){\r\n            fromStart.isVisited = true\r\n            visitedNodes.push(fromStart)\r\n            const startNeighbours = getNeighbours(grid, fromStart, 'from_start')\r\n            for(const neighbour of startNeighbours){\r\n                neighbour.previousNode = fromStart\r\n                queue1.push(neighbour)\r\n            }\r\n        } else{\r\n            fromFinish.isVisitedFromOther = true\r\n            visitedNodes.push(fromFinish)\r\n            const finishNeighbours = getNeighbours(grid, fromFinish, 'from_finish')\r\n            for(const neighbour of finishNeighbours){\r\n                neighbour.nextNode = fromFinish\r\n                queue2.push(neighbour)\r\n            }\r\n            fromStart.isVisited = true\r\n            visitedNodes.push(fromStart)\r\n            const startNeighbours = getNeighbours(grid, fromStart, 'from_start')\r\n            for(const neighbour of startNeighbours){\r\n                neighbour.previousNode = fromStart\r\n                queue1.push(neighbour)\r\n            }\r\n        }\r\n\r\n    }\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbours(grid, node, direction){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n\r\n    if(direction === 'from_start')\r\n        return neighbours.filter(neighbour => !neighbour.isVisited && !neighbour.isWall)\r\n    return neighbours.filter(neighbour => !neighbour.isVisitedFromOther && !neighbour.isWall)\r\n}\r\nexport function getBidirectionalShortestPath(middle1 , finishNode){\r\n    const pathList = []\r\n    const path1 = []\r\n    const path2 = []\r\n    let middle2 = middle1.nextNode\r\n    while(middle1 !== null){\r\n        middle1.isPath = true\r\n        path1.unshift(middle1)\r\n        middle1 = middle1.previousNode\r\n    }\r\n\r\n    while(middle2 !== null){\r\n        middle2.isPath = true\r\n        path2.push(middle2)\r\n        middle2 = middle2.nextNode\r\n    }\r\n\r\n    return path1.concat(path2)\r\n}","export function recursiveDivsionUtil(grid, startRow, endRow, startCol, endCol, direction, boundaryWalls){\r\n    const wallsToAnimate = []    \r\n    recursiveDivsion(grid, startRow, endRow, startCol, endCol, direction, boundaryWalls, wallsToAnimate);\r\n    console.log(wallsToAnimate);\r\n    console.log(grid)\r\n    return wallsToAnimate;\r\n}\r\n\r\nfunction recursiveDivsion(grid, startRow, endRow, startCol, endCol, direction, boundaryWalls, wallsToAnimate){\r\n    if(startRow > endRow || startCol > endCol){\r\n        return;\r\n    }\r\n\r\n    if(boundaryWalls){\r\n\r\n        for(let row = 0; row < grid.length; row++){\r\n            for(let col = 0; col < grid[0].length; col++){\r\n                if(row === 0 || col === 0 || row === grid.length - 1 || col === grid[0].length - 1){\r\n                    const node = grid[row][col];\r\n                    if(node.isStart || node.isFinish){\r\n                        continue;\r\n                    }\r\n                    node.isWall = true;\r\n                    wallsToAnimate.push(node);\r\n                }\r\n            }\r\n        }\r\n        boundaryWalls = false;\r\n    }\r\n\r\n    if(direction===\"horizontal\"){\r\n\r\n        let possibleRows = []\r\n        for(let i = startRow; i <= endRow; i += 2){\r\n            possibleRows.push(i);\r\n        }\r\n\r\n        let possibleColumns = []\r\n        for(let i = startCol - 1; i <= endCol + 1; i += 2){\r\n            possibleColumns.push(i);\r\n        }\r\n\r\n        let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n        let randomColumnIndex = Math.floor(Math.random() * possibleColumns.length);\r\n\r\n        let selectedRowPartition = possibleRows[randomRowIndex];\r\n        let selectedColumnPartition = possibleColumns[randomColumnIndex];\r\n\r\n        for(let row = 0; row < grid.length; row++){\r\n            for(let col = 0; col < grid[0].length; col++){\r\n                if(row === selectedRowPartition && col !== selectedColumnPartition && col >= startCol - 1 && col <= endCol + 1){\r\n                    const node = grid[row][col];\r\n                    if(node.isStart || node.isFinish){\r\n                        continue;\r\n                    }\r\n                    node.isWall = true;\r\n                    wallsToAnimate.push(node);\r\n                }\r\n            } \r\n        }\r\n\r\n        if(selectedRowPartition - 2 - startRow > endCol - startCol){\r\n            recursiveDivsion(grid, startRow, selectedRowPartition - 2, startCol , endCol, direction, boundaryWalls, wallsToAnimate);\r\n        } else {\r\n            recursiveDivsion(grid, startRow, selectedRowPartition - 2, startCol , endCol, \"vertical\", boundaryWalls, wallsToAnimate);\r\n        }\r\n\r\n        if(endRow -(selectedRowPartition + 2) > endCol - startCol){\r\n            recursiveDivsion(grid, selectedRowPartition + 2, endRow, startCol , endCol, direction, boundaryWalls, wallsToAnimate);\r\n        }else{\r\n            recursiveDivsion(grid, selectedRowPartition + 2, endRow, startCol , endCol, \"vertical\", boundaryWalls, wallsToAnimate);\r\n        }\r\n\r\n    }else{\r\n\r\n        let possibleColumns = []\r\n        for(let i = startCol; i <= endCol; i += 2){\r\n            possibleColumns.push(i);\r\n        }\r\n\r\n        let possibleRows = []\r\n        for(let i = startRow - 1; i <= endRow + 1; i += 2){\r\n            possibleRows.push(i);\r\n        }\r\n\r\n        let randomColumnIndex = Math.floor(Math.random() * possibleColumns.length);\r\n        let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n\r\n        let selectedColumnPartition = possibleColumns[randomColumnIndex];\r\n        let selectedRowPartition = possibleRows[randomRowIndex];\r\n\r\n        for(let row = 0; row < grid.length; row++){\r\n            for(let col = 0; col < grid[0].length; col++){\r\n                if(col === selectedColumnPartition && row !== selectedRowPartition && row >= startRow - 1 && row <= endRow + 1){\r\n                    const node = grid[row][col];\r\n                    if(node.isStart || node.isFinish){\r\n                        continue;\r\n                    }\r\n                    node.isWall = true;\r\n                    wallsToAnimate.push(node);\r\n                }\r\n            } \r\n        }\r\n\r\n        if(endRow - startRow > selectedColumnPartition - 2- startCol){\r\n            recursiveDivsion(grid, startRow, endRow, startCol , selectedColumnPartition - 2, \"horizontal\", boundaryWalls, wallsToAnimate);\r\n        }else{\r\n            recursiveDivsion(grid, startRow, endRow, startCol , selectedColumnPartition - 2, direction, boundaryWalls, wallsToAnimate);\r\n        }\r\n\r\n        if(endRow - startRow > endCol - (selectedColumnPartition + 2)){\r\n            recursiveDivsion(grid, startRow, endRow, selectedColumnPartition + 2, endCol, \"horizontal\", boundaryWalls, wallsToAnimate);\r\n        }else{\r\n            recursiveDivsion(grid, startRow, endRow, selectedColumnPartition + 2, endCol, direction, boundaryWalls, wallsToAnimate);       \r\n        }\r\n\r\n    }\r\n\r\n}","var wallsToAnimate = [];\r\nexport function randomeMaze(\r\n  grid,\r\n  startCol,\r\n  endCol,\r\n) {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      let randomValue = Math.random();\r\n      \r\n        const node = grid[row][col];\r\n        if (node.isStart || node.isFinish) {\r\n          continue;\r\n        }\r\n        if (randomValue < 0.3) {\r\n          node.isWall = true;\r\n          wallsToAnimate.push(node);\r\n        }\r\n      \r\n    }\r\n  }\r\n  return wallsToAnimate;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra, getShortestPath } from \"../Algorithms/dijkstra\";\r\nimport { depthFirstSearch, getDFSPath } from \"../Algorithms/depthFirstSearch\";\r\nimport {\r\n  breadthFristSearch,\r\n  getBFSPath\r\n} from \"../Algorithms/breadthFirstSearch\";\r\nimport { bestFirstSearch, getGBFSPath } from \"../Algorithms/bestFirstSearch\";\r\nimport { aStarSearch, getAStarPath } from \"../Algorithms/aStarSearch\";\r\nimport {\r\n  bidirectionalSearch,\r\n  getBidirectionalShortestPath\r\n} from \"../Algorithms/bidirectionalSearch\";\r\nimport { recursiveDivsionUtil } from \"../MazeGenerationAlgorithms/RecursiveDivisionMazeGeneration\";\r\nimport { randomeMaze } from \"../MazeGenerationAlgorithms/RandomMaze\";\r\n\r\nimport Nav from \"react-bootstrap/Nav\";\r\nimport Navbar from \"react-bootstrap/Navbar\";\r\nimport NavDropdown from \"react-bootstrap/NavDropdown\";\r\n\r\nimport \"./VisualizerComponent.css\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\n\r\nconst START_POS_ROW = 10;\r\nconst START_POS_COL = 7;\r\nconst FINISH_POS_ROW = 11;\r\nconst FINISH_POS_COL = 45;\r\nconst SLOW_SPEED = 60;\r\nconst MEDIUM_SPEED = 30;\r\nconst FAST_SPEED = 15;\r\n\r\nexport class VisualizerComponent extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      grid: [],\r\n      mousePressed: false,\r\n      mousePointerEvents: \"auto\",\r\n      selectedAlgorithm: \"\",\r\n      speed: \"fast\",\r\n      animationSpeed: 15,\r\n      description: \"Select any path finding algorithm and play!!!\"\r\n    };\r\n\r\n    //Refs for all the nodes\r\n    this.nodeRef = [];\r\n  }\r\n\r\n  handleMouseClick = (row, col) => {\r\n    if (!this.state.grid[row][col].isWall) {\r\n      const newGrid = this.buildWall(row, col);\r\n      this.setState({ grid: newGrid });\r\n    } else {\r\n      const newGrid = this.removeWall(row, col);\r\n      this.setState({ grid: newGrid });\r\n    }\r\n  };\r\n\r\n  handleMouseDown = (row, col) => {\r\n    console.log(\"mouse down\");\r\n    //if(this.state.algorithmRunning) return\r\n    if (this.state.grid[row][col].isStart || this.state.grid[row][col].isFinish)\r\n      return;\r\n    if (!this.state.grid[row][col].isWall) {\r\n      const newGrid = this.buildWall(row, col);\r\n      this.tempGrid = newGrid;\r\n      this.mousePressed = true;\r\n      this.nodeRef[row][col].current.toggleWall();\r\n      //this.setState({/*grid : newGrid,*/ mousePressed : true})\r\n    } else {\r\n      const newGrid = this.removeWall(row, col);\r\n      this.tempGrid = newGrid;\r\n      this.nodeRef[row][col].current.toggleReset();\r\n      //this.setState({grid : newGrid})\r\n    }\r\n  };\r\n\r\n  handleMouseEnter = (row, col) => {\r\n    console.log(\"mouse enter\");\r\n    //if(this.state.algorithmRunning) return\r\n    if (this.state.grid[row][col].isStart || this.state.grid[row][col].isFinish)\r\n      return;\r\n    if (this.mousePressed) {\r\n      if (!this.state.grid[row][col].isWall) {\r\n        const newGrid = this.buildWall(row, col);\r\n        this.tempGrid = newGrid;\r\n        this.nodeRef[row][col].current.toggleWall();\r\n        //this.setState({grid : newGrid})\r\n      } else {\r\n        /*const newGrid = this.removeWall(row, col)\r\n            this.tempGrid = newGrid\r\n            this.nodeRef[row][col].current.toggleReset()*/\r\n        //this.setState({grid : newGrid})\r\n      }\r\n    }\r\n  };\r\n\r\n  handleMouseUp = () => {\r\n    console.log(\"mouse up\");\r\n    this.mousePressed = false;\r\n    this.setState({ grid: this.tempGrid /*, mousePressed : false*/ });\r\n  };\r\n\r\n  buildWall = (row, col) => {\r\n    const newGrid = this.state.grid;\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  removeWall = (row, col) => {\r\n    const newGrid = this.state.grid;\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = [];\r\n\r\n    for (let row = 0; row < 21; row++) {\r\n      const columnRow = [];\r\n      const rowRef = [];\r\n      for (let column = 0; column < 51; column++) {\r\n        columnRow.push(this.createNode(row, column));\r\n        rowRef.push(React.createRef());\r\n      }\r\n      this.nodeRef.push(rowRef);\r\n      grid.push(columnRow);\r\n    }\r\n    this.setState({ grid: grid });\r\n    //console.log(grid)\r\n  }\r\n\r\n  createNode = (row, col) => {\r\n    const newNode = {\r\n      row,\r\n      col,\r\n      isStart: row === START_POS_ROW && col === START_POS_COL,\r\n      isFinish: row === FINISH_POS_ROW && col === FINISH_POS_COL,\r\n      distance: Infinity,\r\n      hCost: null,\r\n      gCost: null,\r\n      fCost: null,\r\n      previousNode: null,\r\n      nextNode: null,\r\n      isVisited: false,\r\n      isVisitedFromOther: false,\r\n      isWall: false,\r\n      isPath: false\r\n    };\r\n    return newNode;\r\n  };\r\n\r\n  clearVisitedNode = removeWall => {\r\n    const newGrid = this.state.grid;\r\n    for (const row of newGrid) {\r\n      for (const node of row) {\r\n        const { row, col } = node;\r\n        if (node.isStart) {\r\n          this.resetStartNode(row, col, newGrid, node);\r\n        } else if (node.isFinish) {\r\n          this.resetFinishNode(row, col, newGrid, node);\r\n        } else if (node.isWall) {\r\n          this.resetWallNode(row, col, newGrid, node, removeWall);\r\n        } else {\r\n          this.resetVisitedNode(row, col, newGrid, node);\r\n        }\r\n      }\r\n    }\r\n    this.setState({ grid: newGrid });\r\n    //console.log(this.state.grid)\r\n  };\r\n\r\n  resetStartNode = (row, col, grid, node) => {\r\n    const newNode = {\r\n      ...node,\r\n      isPath: false,\r\n      isVisited: false,\r\n      isVisitedFromOther: false,\r\n      previousNode: null,\r\n      nextNode: null,\r\n      distance: Infinity,\r\n      hCost: null,\r\n      gCost: null,\r\n      fCost: null\r\n    };\r\n    grid[row][col] = newNode;\r\n    this.nodeRef[node.row][node.col].current.toggleStart();\r\n  };\r\n\r\n  resetFinishNode = (row, col, grid, node) => {\r\n    const newNode = {\r\n      ...node,\r\n      isPath: false,\r\n      isVisited: false,\r\n      isVisitedFromOther: false,\r\n      previousNode: null,\r\n      nextNode: null,\r\n      distance: Infinity,\r\n      hCost: null,\r\n      gCost: null,\r\n      fCost: null\r\n    };\r\n    grid[row][col] = newNode;\r\n    this.nodeRef[node.row][node.col].current.toggleFinish();\r\n  };\r\n\r\n  resetWallNode = (row, col, grid, node, removeWall) => {\r\n    if (removeWall) {\r\n      this.resetVisitedNode(row, col, grid, node);\r\n    } else {\r\n      const newNode = {\r\n        ...node,\r\n        isPath: false,\r\n        isVisited: false,\r\n        isVisitedFromOther: false,\r\n        previousNode: null,\r\n        nextNode: null,\r\n        isWall: true,\r\n        distance: Infinity,\r\n        hCost: null,\r\n        gCost: null,\r\n        fCost: null\r\n      };\r\n      grid[row][col] = newNode;\r\n    }\r\n  };\r\n\r\n  resetVisitedNode = (row, col, grid, node) => {\r\n    const newNode = {\r\n      ...node,\r\n      isPath: false,\r\n      isVisited: false,\r\n      isVisitedFromOther: false,\r\n      previousNode: null,\r\n      nextNode: null,\r\n      isWall: false,\r\n      distance: Infinity,\r\n      hCost: null,\r\n      gCost: null,\r\n      fCost: null\r\n    };\r\n\r\n    grid[row][col] = newNode;\r\n    this.nodeRef[node.row][node.col].current.toggleReset();\r\n  };\r\n\r\n  animateDijkstra = (visitedNodeInOrder, shortestPath) => {\r\n    const grid = this.state.grid;\r\n    const { animationSpeed } = this.state;\r\n    for (let i = 0; i < visitedNodeInOrder.length; i++) {\r\n      grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] =\r\n        visitedNodeInOrder[i];\r\n      if (i === visitedNodeInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.printShortestPath(shortestPath, grid);\r\n        }, animationSpeed * i);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodeInOrder[i];\r\n        this.nodeRef[node.row][node.col].current.toggleVisited();\r\n      }, animationSpeed * i);\r\n    }\r\n  };\r\n\r\n  printShortestPath = (shortestPath, grid) => {\r\n    const { animationSpeed } = this.state;\r\n    if (shortestPath.length === 0) {\r\n      setTimeout(() => {\r\n        this.setState({ mousePointerEvents: \"auto\" });\r\n      }, animationSpeed);\r\n      return;\r\n    }\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPath[i];\r\n        //console.log(grid[node.row][node.col])\r\n        grid[node.row][node.col] = node;\r\n        this.nodeRef[node.row][node.col].current.togglePath();\r\n        if (i === shortestPath.length - 1) {\r\n          this.setState({ grid: grid });\r\n          setTimeout(() => {\r\n            this.setState({ mousePointerEvents: \"auto\" });\r\n          }, animationSpeed * i + 1);\r\n        }\r\n      }, animationSpeed * i);\r\n    }\r\n    //console.log(this.state.algorithmRunning)\r\n  };\r\n\r\n  visualizeDijkstra = () => {\r\n    //console.log(this.state.algorithmRunning)\r\n    this.setState({ mousePointerEvents: \"none\" });\r\n    //console.log(this.state.algorithmRunning)\r\n    this.clearVisitedNode(false);\r\n\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_POS_ROW][START_POS_COL];\r\n      const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL];\r\n      const visitedNodeInOrder = dijkstra(grid.slice(), startNode, finishNode);\r\n      if (!visitedNodeInOrder) return;\r\n      const shortestPath = getShortestPath(finishNode);\r\n      this.animateDijkstra(visitedNodeInOrder, shortestPath);\r\n    }, 100);\r\n  };\r\n\r\n  animateDepthFirstSearch = (visitedNodeInOrder, DFSPath) => {\r\n    const grid = this.state.grid;\r\n    const { animationSpeed } = this.state;\r\n    for (let i = 0; i < visitedNodeInOrder.length; i++) {\r\n      grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] =\r\n        visitedNodeInOrder[i];\r\n      if (i === visitedNodeInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.printShortestPath(DFSPath, grid);\r\n        }, i * animationSpeed);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodeInOrder[i];\r\n        this.nodeRef[node.row][node.col].current.toggleVisited();\r\n      }, i * animationSpeed);\r\n    }\r\n  };\r\n\r\n  visualizeDepthFirstSearch = () => {\r\n    this.setState({ mousePointerEvents: \"none\" });\r\n    this.clearVisitedNode(false);\r\n\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      //console.log(grid)\r\n      const startNode = grid[START_POS_ROW][START_POS_COL];\r\n      const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL];\r\n      //console.log(JSON.stringify(startNode)+\" \"+JSON.stringify(finishNode))\r\n      const visitedNodeInOrder = depthFirstSearch(\r\n        grid.slice(),\r\n        startNode,\r\n        finishNode\r\n      );\r\n      if (!visitedNodeInOrder) return;\r\n      const DFSPath = getDFSPath(finishNode);\r\n      this.animateDepthFirstSearch(visitedNodeInOrder, DFSPath);\r\n    }, 100);\r\n  };\r\n\r\n  animateBreadthFirstSearch = (visitedNodeInOrder, DFSPath) => {\r\n    const grid = this.state.grid;\r\n    const { animationSpeed } = this.state;\r\n    for (let i = 0; i < visitedNodeInOrder.length; i++) {\r\n      grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] =\r\n        visitedNodeInOrder[i];\r\n      if (i === visitedNodeInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.printShortestPath(DFSPath, grid);\r\n        }, i * animationSpeed);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodeInOrder[i];\r\n        this.nodeRef[node.row][node.col].current.toggleVisited();\r\n      }, i * animationSpeed);\r\n    }\r\n  };\r\n\r\n  visualizeBreadthFirstSearch = () => {\r\n    this.setState({ mousePointerEvents: \"none\" });\r\n    this.clearVisitedNode(false);\r\n\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_POS_ROW][START_POS_COL];\r\n      const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL];\r\n      console.log(grid);\r\n      const visitedNodeInOrder = breadthFristSearch(\r\n        grid.slice(),\r\n        startNode,\r\n        finishNode\r\n      );\r\n      if (!visitedNodeInOrder) return;\r\n      //console.log(visitedNodeInOrder)\r\n      const BFSPath = getBFSPath(finishNode);\r\n      this.animateBreadthFirstSearch(visitedNodeInOrder, BFSPath);\r\n    }, 100);\r\n  };\r\n\r\n  animateBestFirstSearch = (visitedNodeInOrder, GBFSPath) => {\r\n    const grid = this.state.grid;\r\n    const { animationSpeed } = this.state;\r\n    for (let i = 0; i < visitedNodeInOrder.length; i++) {\r\n      grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] =\r\n        visitedNodeInOrder[i];\r\n      if (i === visitedNodeInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.printShortestPath(GBFSPath, grid);\r\n        }, i * animationSpeed);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodeInOrder[i];\r\n        this.nodeRef[node.row][node.col].current.toggleVisited();\r\n      }, i * animationSpeed);\r\n    }\r\n  };\r\n\r\n  visualizeBestFirstSearch = () => {\r\n    this.setState({ mousePointerEvents: \"none\" });\r\n    this.clearVisitedNode(false);\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_POS_ROW][START_POS_COL];\r\n      const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL];\r\n      //console.log(grid)\r\n      const visitedNodeInOrder = bestFirstSearch(\r\n        grid.slice(),\r\n        startNode,\r\n        finishNode\r\n      );\r\n      if (!visitedNodeInOrder) return;\r\n      //console.log(visitedNodeInOrder)\r\n      const GBFSPath = getGBFSPath(finishNode);\r\n      //console.log(GBFSPath)\r\n      this.animateBestFirstSearch(visitedNodeInOrder, GBFSPath);\r\n    }, 100);\r\n  };\r\n\r\n  animateAStarSearch = (visitedNodeInOrder, AStarPath) => {\r\n    const grid = this.state.grid;\r\n    const { animationSpeed } = this.state;\r\n    for (let i = 0; i < visitedNodeInOrder.length; i++) {\r\n      grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] =\r\n        visitedNodeInOrder[i];\r\n      if (i === visitedNodeInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.printShortestPath(AStarPath, grid);\r\n        }, (i * animationSpeed) / 1.5);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodeInOrder[i];\r\n        this.nodeRef[node.row][node.col].current.toggleVisited();\r\n      }, (i * animationSpeed) / 1.5);\r\n    }\r\n  };\r\n\r\n  visualizeAStarSearch = () => {\r\n    this.setState({ mousePointerEvents: \"none\" });\r\n    this.clearVisitedNode(false);\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      console.log(grid);\r\n      const startNode = grid[START_POS_ROW][START_POS_COL];\r\n      const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL];\r\n      //console.log(grid)\r\n      const visitedNodeInOrder = aStarSearch(\r\n        grid.slice(),\r\n        startNode,\r\n        finishNode\r\n      );\r\n      if (!visitedNodeInOrder) return;\r\n      console.log(visitedNodeInOrder);\r\n      const AStarPath = getAStarPath(finishNode);\r\n      //console.log(GBFSPath)\r\n      this.animateAStarSearch(visitedNodeInOrder, AStarPath);\r\n    }, 100);\r\n  };\r\n\r\n  animateBidirectionalSearch = (visitedNodeInOrder, GBFSPath) => {\r\n    const grid = this.state.grid;\r\n    const { animationSpeed } = this.state;\r\n    for (let i = 0; i < visitedNodeInOrder.length; i++) {\r\n      grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] =\r\n        visitedNodeInOrder[i];\r\n      if (i === visitedNodeInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.printShortestPath(GBFSPath, grid);\r\n        }, (i * animationSpeed) / 1.5);\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodeInOrder[i];\r\n        this.nodeRef[node.row][node.col].current.toggleVisited();\r\n      }, (i * animationSpeed) / 1.5);\r\n    }\r\n  };\r\n\r\n  visualizeBidirectionalSearch = () => {\r\n    this.setState({ mousePointerEvents: \"none\" });\r\n    this.clearVisitedNode(false);\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_POS_ROW][START_POS_COL];\r\n      const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL];\r\n      //console.log(grid)\r\n      const visitedNodeInOrder = bidirectionalSearch(\r\n        grid.slice(),\r\n        startNode,\r\n        finishNode\r\n      );\r\n      //console.log(visitedNodeInOrder.pop())\r\n      if (!visitedNodeInOrder) return;\r\n      console.log(visitedNodeInOrder.length);\r\n      const middle1 = visitedNodeInOrder[visitedNodeInOrder.length - 1];\r\n      const path = getBidirectionalShortestPath(middle1, finishNode);\r\n      //console.log(middle1)\r\n      console.log(path);\r\n      this.animateBidirectionalSearch(visitedNodeInOrder, path);\r\n    }, 100);\r\n  };\r\n\r\n  visualizeSelectedAlgorithm = () => {\r\n    const { selectedAlgorithm } = this.state;\r\n    console.log(selectedAlgorithm);\r\n    switch (selectedAlgorithm) {\r\n      case \"Dijkstra Algorithm\":\r\n        this.visualizeDijkstra();\r\n        break;\r\n      case \"Depth first search\":\r\n        this.visualizeDepthFirstSearch();\r\n        break;\r\n      case \"Breadth frist search\":\r\n        this.visualizeBreadthFirstSearch();\r\n        break;\r\n      case \"Greedy Best first search\":\r\n        this.visualizeBestFirstSearch();\r\n        break;\r\n      case \"A* search\":\r\n        this.visualizeAStarSearch();\r\n        break;\r\n      case \"Bidirectional BFS\":\r\n        this.visualizeBidirectionalSearch();\r\n        break;\r\n      default:\r\n        window.alert(\"select an algorithm!\");\r\n    }\r\n  };\r\n\r\n  selectAlgorithm = algorithm => {\r\n    //console.log(algorithm)\r\n    let description = \"\";\r\n    switch (algorithm) {\r\n      case \"Dijkstra Algorithm\":\r\n        description =\r\n          \"Dijkstra's algorithm is a weighted graph search algorithm used to find the sortest path between nodes in a graph\";\r\n        break;\r\n      case \"Depth first search\":\r\n        description =\r\n          \"Depth First Search is an unweighted graph search algorithm used for traversing or searching in a graph. It does not guarantee the shortest path\";\r\n        break;\r\n      case \"Breadth frist search\":\r\n        description =\r\n          \"Breadth First Search is an unweighted graph search algorithm used for traversing or searching in a graph. It guarantees the shortest path\";\r\n        break;\r\n      case \"Greedy Best first search\":\r\n        description =\r\n          \"Greedy Best first search is weighted and informed graph search algorithm, It does not guarantee the shortest path\";\r\n        break;\r\n      case \"A* search\":\r\n        description =\r\n          \"A* search is a weighted and informed grapth search algorithm which arguably the best graph search algorithm. It guarantees the shortest path and mush faster than Dijkstra's\";\r\n        break;\r\n      case \"Bidirectional BFS\":\r\n        description =\r\n          \"Bidirectional BFS is an unweighted graph search algorithm which gives the shortest path between the two nodes\";\r\n        break;\r\n    }\r\n    this.setState({ selectedAlgorithm: algorithm, description: description });\r\n    //console.log(this.state.selectedAlgorithm)\r\n  };\r\n\r\n  selectSpeed = speed => {\r\n    switch (speed) {\r\n      case \"slow\":\r\n        this.setState({ animationSpeed: SLOW_SPEED, speed: speed });\r\n        break;\r\n      case \"medium\":\r\n        this.setState({ animationSpeed: MEDIUM_SPEED, speed: speed });\r\n        break;\r\n      case \"fast\":\r\n        this.setState({ animationSpeed: FAST_SPEED, speed: speed });\r\n        break;\r\n    }\r\n  };\r\n\r\n  generateWalls = algorithm => {\r\n    this.setState({ mousePointerEvents: \"none\" });\r\n    this.clearVisitedNode(true);\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      let wallsToAnimate = [];\r\n      switch (algorithm) {\r\n        case \"recursive_division_horizontal\":\r\n          wallsToAnimate = recursiveDivsionUtil(\r\n            grid,\r\n            2,\r\n            grid.length - 3,\r\n            2,\r\n            grid[0].length - 3,\r\n            \"horizontal\",\r\n            true\r\n          );\r\n          break;\r\n        case \"recursive_division_vertical\":\r\n          wallsToAnimate = recursiveDivsionUtil(\r\n            grid,\r\n            2,\r\n            grid.length - 3,\r\n            2,\r\n            grid[0].length - 3,\r\n            \"vertical\",\r\n            true\r\n          );\r\n          break;\r\n        case \"random\":\r\n          wallsToAnimate = randomeMaze(grid);\r\n      }\r\n      //console.log(wallsToAnimate)\r\n      this.animateWalls(wallsToAnimate);\r\n    }, 500);\r\n  };\r\n\r\n  animateWalls = wallsToAnimate => {\r\n    const { grid } = this.state;\r\n    for (let i = 0; i < wallsToAnimate.length; i++) {\r\n      setTimeout(() => {\r\n      const node = wallsToAnimate[i];\r\n      const { row, col } = node;\r\n      this.nodeRef[row][col].current.toggleWall();\r\n      grid[row][col].isWall = true;\r\n      //console.log(\"i=\"+i+\" len=\"+wallsToAnimate.length)  \r\n      if (i === wallsToAnimate.length - 1) {\r\n          setTimeout(() => {\r\n            console.log(\"last\")  \r\n            this.setState({ mousePointerEvents: \"auto\", grid:grid});\r\n          },10 );\r\n        }\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const grid = this.state.grid;\r\n    //console.log(grid)\r\n    //Building the grid with table and table data as Node component\r\n\r\n    return (\r\n      <div className=\"container-fluid\">\r\n        <div>\r\n          <Navbar bg=\"light\">\r\n            <Navbar.Brand href=\"#\">Algorithm Visualizer</Navbar.Brand>\r\n            <NavDropdown\r\n              title=\"Select Algorithm\"\r\n              id=\"basic-nav-dropdown\"\r\n              style={{ pointerEvents: this.state.mousePointerEvents }}\r\n            >\r\n              <NavDropdown.Item\r\n                href=\"\"\r\n                onClick={() => this.selectAlgorithm(\"Dijkstra Algorithm\")}\r\n              >\r\n                Dijkstra\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item\r\n                href=\"\"\r\n                onClick={() => this.selectAlgorithm(\"Depth first search\")}\r\n              >\r\n                Depth First Search\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item\r\n                href=\"\"\r\n                onClick={() => this.selectAlgorithm(\"Breadth frist search\")}\r\n              >\r\n                Breadth First Search\r\n              </NavDropdown.Item>\r\n              \r\n              <NavDropdown.Item\r\n                href=\"\"\r\n                onClick={() => this.selectAlgorithm(\"A* search\")}\r\n              >\r\n                A* Search\r\n              </NavDropdown.Item>\r\n             \r\n            </NavDropdown>\r\n            <NavDropdown\r\n              title=\"Generate Maze\"\r\n              style={{ pointerEvents: this.state.mousePointerEvents }}\r\n            >\r\n              <NavDropdown.Item\r\n                onClick={() =>\r\n                  this.generateWalls(\"recursive_division_horizontal\")\r\n                }\r\n              >\r\n                Horizontal Recursive Division\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item\r\n                onClick={() =>\r\n                  this.generateWalls(\"recursive_division_vertical\")\r\n                }\r\n              >\r\n                Vertical Recursive Division\r\n              </NavDropdown.Item>\r\n              <NavDropdown.Item onClick={() => this.generateWalls(\"random\")}>\r\n                Random Maze\r\n              </NavDropdown.Item>\r\n            </NavDropdown>\r\n\r\n            <Nav.Link\r\n              onClick={() => this.clearVisitedNode(true)}\r\n              style={{ pointerEvents: this.state.mousePointerEvents }}\r\n            >\r\n              Clear Board\r\n            </Nav.Link>\r\n            <Nav.Link\r\n              className=\"btn btn-danger\"\r\n              onClick={() => this.visualizeSelectedAlgorithm()}\r\n              style={{ pointerEvents: this.state.mousePointerEvents }}\r\n            >\r\n              Visualize {this.state.selectedAlgorithm}\r\n            </Nav.Link>\r\n            \r\n          </Navbar>\r\n        </div>\r\n        <div>\r\n          <p className=\"container description\">{this.state.description}</p>\r\n        </div>\r\n        <div\r\n          className=\"grid\"\r\n          style={{ pointerEvents: this.state.mousePointerEvents }}\r\n        >\r\n          <table>\r\n            <tbody>\r\n              {grid.map((row, rowId) => {\r\n                return (\r\n                  <tr className=\"tr-height\" key={rowId}>\r\n                    {row.map((column, columnId) => (\r\n                      <td key={columnId}>\r\n                        <Node\r\n                          row={column.row}\r\n                          col={column.col}\r\n                          isStart={column.isStart}\r\n                          isFinish={column.isFinish}\r\n                          isWall={column.isWall}\r\n                          isPath={column.isPath}\r\n                          isVisited={column.isVisited}\r\n                          onMouseDown={(row, col) =>\r\n                            this.handleMouseDown(row, col)\r\n                          }\r\n                          onMouseEnter={(row, col) =>\r\n                            this.handleMouseEnter(row, col)\r\n                          }\r\n                          onMouseUp={() => this.handleMouseUp()}\r\n                          ref={this.nodeRef[column.row][column.col]}\r\n                        />\r\n                      </td>\r\n                    ))}\r\n                  </tr>\r\n                );\r\n              })}\r\n            </tbody>\r\n          </table>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default VisualizerComponent;\r\n","import React from 'react';\r\nimport './App.css';\r\nimport Visualizer from './components/VisualizerComponent'\r\nimport 'bootstrap/dist/css/bootstrap.min.css'\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Visualizer/>\r\n    </div>\r\n  );\r\n} \r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}